from django.shortcuts import render
from django.views.generic import ListView, DetailView
# (Seungeon)
from users.models import Profile, Property
from django.db.models import Q


def home(request):
    profile = Profile.objects.all()
    context = {
        "profile": profile
    }
    return render(
        request=request, 
        template_name='social_app/home.html',
        context=context,
        )

# (Seungeon)l
# by default,
# url : <app>/<model>_<viewtype>.html
# in our case, 'users/profile_list.html'


# class ProfileListView(ListView):
#     # this behaves same as model = Profile.objects.get.all()
#     model = Profile
#     # The template_name attribute is used to tell Django to use a specific template name
#     # instead of the autogenerated default template name
#     template_name = 'social_app/home.html'
#     # Designates the name of the variable to use in the context.
#     # from Django official Docs
#     # https://docs.djangoproject.com/en/3.1/ref/class-based-views/mixins-single-object/
#     context_object_name = 'profiles'
#     # ordering = [-some attribute] <- this will order it by whatever attribute in models.py specified

#     def get_queryset(self):
#         queryset = Profile.objects.exclude(user__username="admin")
#         return queryset

class ProfileListView(ListView):
    # this behaves same as model = Profile.objects.get.all()
    model = Profile
    # The template_name attribute is used to tell Django to use a specific template name
    # instead of the autogenerated default template name
    template_name = 'social_app/profile_list.html'
    # Designates the name of the variable to use in the context.
    # from Django official Docs
    # https://docs.djangoproject.com/en/3.1/ref/class-based-views/mixins-single-object/
    context_object_name = 'profiles'
    # ordering = [-some attribute] <- this will order it by whatever attribute in models.py specified

    def get_queryset(self):
        # queryset = Profile.objects.filter(property__pk__isnull = True).exclude(user__username="admin").exclude(display_profile=False)
        queryset = Profile.objects.filter(Q(display_profile=True) & Q(property__display_property=False))
        return queryset

class PreferenceListView(ListView):
    # this behaves same as model = Profile.objects.get.all()
    model = Profile
    # The template_name attribute is used to tell Django to use a specific template name
    # instead of the autogenerated default template name
    template_name = 'social_app/top_matches_list.html'
    # Designates the name of the variable to use in the context.
    # from Django official Docs
    # https://docs.djangoproject.com/en/3.1/ref/class-based-views/mixins-single-object/
    context_object_name = 'profiles'
    # ordering = [-some attribute] <- this will order it by whatever attribute in models.py specified

    def get_queryset(self):
        # profile = property_list if user wants to be matched w/ ppl w/ properties, profile_list if user wants to be match w/ onyl no propt, both if no preference
        # score = 0
        # top_profile_list = []
        # for all profile in profiles:
            # for all preferences:
                # if preference matches listing info:
                    # score += 1
                    # top_profile_list.append((profile, score))
        # sort(top_profile_list)
        # display top_profile_list[:10]
                    
        # get "scores", where score = # of matches btwn preferences + given profile
        # sort scores from greatest to least
        # diplay top 10 profiles that have the highest score (first 10 profiles in sorted scores list)

        score = 0
        top_profile_list = list()
        # queryset = Profile.objects.filter(property__pk__isnull = True).exclude(user__username="admin").exclude(display_profile=False)
        queryset = Profile.objects.filter(Q(display_profile=True) & Q(property__display_property=False))
        return queryset

def preference_list_view(request):
    profile_all = Profile.objects.all()
    profile = Profile.objects.get(user__pk=request.user.pk)

    score = 0
    top_profile_list = list()
    if (profile.match_list == "Both"):
        display_list = Profile.objects.filter(Q(match_list__icontains="both") & Q(display_profile=True) & Q(property__display_property=True)).exclude(user__pk=request.user.pk)
        for d in display_list:
            pass
    if (profile.match_list == "Property"):
        display_list = Profile.objects.filter(Q(display_profile=True) & Q(property__display_property=True)).exclude(user__pk=request.user.pk)
        for d in display_list:
            if d.property.rent != None:
                if(d.property.rent <= profile.max_price):
                    score += 1
                    top_profile_list.append((d, score))
        #display_list = Profile.objects.filter(property__pk__isnull=False).filter(Q(property__display_property=True))
    if (profile.match_list == "Profile"):
        display_list = Profile.objects.filter(Q(display_profile=True) & Q(property__display_property=False)).exclude(user__pk=request.user.pk)
        #display_list = Profile.filter(property__pk__isnull=True).filter(Q(display_profile=True))

    context = {
        "display_list": top_profile_list
    }
    return render(
        request=request,
        template_name='social_app/top_matches_list.html',
        context=context,
    )
class PropertyListView(ListView):
    model = Profile
    template_name = 'social_app/property_list.html'
    context_object_name = "profiles"

    def get_queryset(self):
        queryset = Profile.objects.filter(Q(display_profile=True) & Q(property__display_property=True))
        return queryset

def profile_detail_view(request, pk):
    profile = Profile.objects.get(user__pk=pk)
    context = {
        "profile": profile,
        }
    return render(
        request=request,
        template_name='social_app/detail.html',
        context=context,
    )

# def profile_detail_view(request, pk):
    # profile = Profile.objects.get(user__pk=pk)
    # context = {
    #     "profile": profile,
    #     }
    # return render(
    #     request=request,
    #     template_name='social_app/detail.html',
    #     context=context,
    # )
    # pass


def about(request):
    return render(
        request=request,
        template_name='social_app/about.html'
    )
