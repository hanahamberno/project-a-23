from django.shortcuts import render
from django.views.generic import ListView, DetailView
# (Seungeon)
from users.models import Profile, Property
from django.db.models import Q


def home(request):
    profile = Profile.objects.all()
    context = {
        "profile": profile
    }
    return render(
        request=request, 
        template_name='social_app/home.html',
        context=context,
        )

# (Seungeon)l
# by default,
# url : <app>/<model>_<viewtype>.html
# in our case, 'users/profile_list.html'


# class ProfileListView(ListView):
#     # this behaves same as model = Profile.objects.get.all()
#     model = Profile
#     # The template_name attribute is used to tell Django to use a specific template name
#     # instead of the autogenerated default template name
#     template_name = 'social_app/home.html'
#     # Designates the name of the variable to use in the context.
#     # from Django official Docs
#     # https://docs.djangoproject.com/en/3.1/ref/class-based-views/mixins-single-object/
#     context_object_name = 'profiles'
#     # ordering = [-some attribute] <- this will order it by whatever attribute in models.py specified

#     def get_queryset(self):
#         queryset = Profile.objects.exclude(user__username="admin")
#         return queryset

class ProfileListView(ListView):
    # this behaves same as model = Profile.objects.get.all()
    model = Profile
    # The template_name attribute is used to tell Django to use a specific template name
    # instead of the autogenerated default template name
    template_name = 'social_app/profile_list.html'
    # Designates the name of the variable to use in the context.
    # from Django official Docs
    # https://docs.djangoproject.com/en/3.1/ref/class-based-views/mixins-single-object/
    context_object_name = 'profiles'
    # ordering = [-some attribute] <- this will order it by whatever attribute in models.py specified

    def get_queryset(self):
        # queryset = Profile.objects.filter(property__pk__isnull = True).exclude(user__username="admin").exclude(display_profile=False)
        queryset = Profile.objects.filter(Q(display_profile=True) & Q(property__display_property=False))
        return queryset

class PreferenceListView(ListView):
    # this behaves same as model = Profile.objects.get.all()
    model = Profile
    # The template_name attribute is used to tell Django to use a specific template name
    # instead of the autogenerated default template name
    template_name = 'social_app/top_matches_list.html'
    # Designates the name of the variable to use in the context.
    # from Django official Docs
    # https://docs.djangoproject.com/en/3.1/ref/class-based-views/mixins-single-object/
    context_object_name = 'profiles'
    # ordering = [-some attribute] <- this will order it by whatever attribute in models.py specified

    def get_queryset(self):
        # profile = property_list if user wants to be matched w/ ppl w/ properties, profile_list if user wants to be match w/ onyl no propt, both if no preference
        # score = 0
        # top_profile_list = []
        # for all profile in profiles:
            # for all preferences:
                # if preference matches listing info:
                    # score += 1
                    # top_profile_list.append((profile, score))
        # sort(top_profile_list)
        # display top_profile_list[:10]
                    
        # get "scores", where score = # of matches btwn preferences + given profile
        # sort scores from greatest to least
        # diplay top 10 profiles that have the highest score (first 10 profiles in sorted scores list)

        score = 0
        top_profile_list = list()
        # queryset = Profile.objects.filter(property__pk__isnull = True).exclude(user__username="admin").exclude(display_profile=False)
        queryset = Profile.objects.filter(Q(display_profile=True) & Q(property__display_property=False))
        return queryset

def preference_list_view(request):
    profile_all = Profile.objects.all()
    profile = Profile.objects.get(user__pk=request.user.pk)
    top_profile_list = []

    if (profile.match_list == "Both" or not profile.match_list):
        # display_list = Profile.objects.filter(Q(display_profile=True)).exclude(user__pk=request.user.pk)
        # for d in display_list:
        #     if d.property_id != None:
        #         if d.property.display_property:
        #             score = 0
        #             # calculate the score for each profile in display_list
        #             for pref in d.preference_list(): #
        #                 if pref != None:
        #                     if(pref == "max_price" and d.property.rent <= profile.max_price):
        #                         score += 1
        #                     if(pref == "on_grounds" and d.property.on_grounds == profile.on_grounds):
        #                         score += 1
        #                     if(pref == "pref_gender"):
        #                         if(profile.pref_gender == "NO_PREFERENCE"):
        #                             score += 1
        #                         else:
        #                             if(d.gender == profile.pref_gender):
        #                                 score += 1
        #     else:
        #         for pref in d.preference_list(): 
        #             if pref != None:
        #                 if(pref == "on_grounds" and d.property.on_grounds == profile.on_grounds):
        #                     score += 1
        #                 if(pref == "pref_gender"):
        #                     if(profile.pref_gender == "NO_PREFERENCE"):
        #                         score += 1
        #                     else:
        #                         if(d.gender == profile.pref_gender):
        #                             score += 1
        pass


    elif (profile.match_list == "Profile"):
        display_list = Profile.objects.filter(Q(display_profile=True) & Q(property__display_property=False)).exclude(user__pk=request.user.pk)
        for d in display_list:
            score = 0
            # calculate the score for each profile in display_list
            for pref in d.preference_list(): #
                print(pref)
                if pref != None:
                    if(pref == "on_grounds" and d.on_grounds == profile.on_grounds):
                        score += 1
                    if(pref == "pref_gender"):
                        if(profile.pref_gender == "NO_PREFERENCE"):
                            score += 1
                        else:
                            if(d.gender == profile.pref_gender):
                                score += 1

    elif (profile.match_list == "Property"):
        display_list = Profile.objects.filter(Q(display_profile=True) & Q(property__display_property=True)).exclude(user__pk=request.user.pk)
        print(display_list)
        for d in display_list:
            score = 0
            # calculate the score for each profile in display_list
            for pref in d.preference_list(): #
                print(pref)
                if pref != None:
                    if(pref == "max_price" and d.property.rent <= profile.max_price):
                        score += 1
                    if(pref == "on_grounds" and d.property.on_grounds == profile.on_grounds):
                        score += 1
                    if(pref == "pref_gender"):
                        if(profile.pref_gender == "NO_PREFERENCE"):
                            score += 1
                        else:
                            if(d.gender == profile.pref_gender):
                                score += 1

            top_profile_list.append((score, d))
    top_profile_list = sorted(top_profile_list, key=lambda x: x[0], reverse=True)
    print(top_profile_list[0:15])
    context = {
        "display_list": top_profile_list[0:15]
    }
    return render(
        request=request,
        template_name='social_app/top_matches_list.html',
        context=context,
    )
class PropertyListView(ListView):
    model = Profile
    template_name = 'social_app/property_list.html'
    context_object_name = "profiles"

    def get_queryset(self):
        queryset = Profile.objects.filter(Q(display_profile=True) & Q(property__display_property=True))
        return queryset

def profile_detail_view(request, pk):
    profile = Profile.objects.get(user__pk=pk)
    context = {
        "profile": profile,
        }
    return render(
        request=request,
        template_name='social_app/detail.html',
        context=context,
    )

# def profile_detail_view(request, pk):
    # profile = Profile.objects.get(user__pk=pk)
    # context = {
    #     "profile": profile,
    #     }
    # return render(
    #     request=request,
    #     template_name='social_app/detail.html',
    #     context=context,
    # )
    # pass


def about(request):
    return render(
        request=request,
        template_name='social_app/about.html'
    )
